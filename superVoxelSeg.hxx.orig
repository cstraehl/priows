#pragma once
#ifndef TWS_ITER_HXX
#define TWS_ITER_HXX

#include <Python.h>
#include <boost/python.hpp>

#include <vector>
#include <queue>
#include <map>

//#include <ext/hash_map>

//#include <google/sparse_hash_map>
//#include <google/dense_hash_map>

#include <queue>

#include <algorithm> // max
#include <map>

#include <vigra/windows.h>
#include <time.h>

#include <vigra/multi_array.hxx>
#include <vigra/numpy_array.hxx>
#include <vigra/numpy_array_converters.hxx>
#include <vigra/multi_pointoperators.hxx>

#include "tws.hxx"
#include "helpers.hxx"

//kolmogorov
#include "kolmogorov/graph.hpp"


//random walker
#include <list>
extern "C" {
#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <lis.h>

void real_error_function(char * s) {
    printf(s);
}
}

namespace std
{
 //using namespace __gnu_cxx;
}



namespace vigra
{

namespace incremental {
     

template<class TYPE_IND, class CT>
class AdjacencyListVertex;

template<class TYPE_IND, class CT>
class AdjacencyListEdge;

template<class TYPE_IND, class CT>
class AdjacencyListEdge {
  public:
    AdjacencyListEdge() {
      min = 0;
      other = 0;
      here = 0;
      sum = 0;
      size = 0;
    }

    AdjacencyListEdge(CT cweight, float suma, unsigned int sizea, TYPE_IND cother, TYPE_IND chere) {
      other = cother;
      here = chere;
      min = cweight;
      sum = suma;
      size = sizea;
    }

    CT min;
    float sum;
    unsigned int size;
    TYPE_IND other;
    TYPE_IND here;

};

template<class TYPE_IND, class CT>
class AdjacencyListVertex {
  public:
    std::vector< AdjacencyListEdge<TYPE_IND, CT > > edges;
    unsigned int totalSize;
    //float average;
    //float price;
    //TYPE_IND volume;
    //TYPE_IND joinedWith;
};

template<class TYPE_IND, class CT>
bool edgeSortFunction(const AdjacencyListEdge<TYPE_IND, CT>& a, const AdjacencyListEdge<TYPE_IND, CT>& b) {
  return a.min < b.min;
}

template<class TYPE_IND, class CT>
class edgeSortClass
{
public:
  edgeSortClass()
  {}
  bool operator() (AdjacencyListEdge<TYPE_IND, CT>* a, AdjacencyListEdge<TYPE_IND, CT>* b) const
  {
    return a->min > b->min;
  }
};

template<class TYPE_IND, class PIXEL_TYPE>
struct PassInfo{
  PassInfo(TYPE_IND  b  = 0, PIXEL_TYPE weight=0) : b(b), weight(weight) {}
  TYPE_IND b;
  PIXEL_TYPE weight;

  bool operator<(const PassInfo<TYPE_IND, PIXEL_TYPE> &b) const
  {
    if (this->b < b.b) {
      return true;
    }
    else if(this->b > b.b) {
      return false;
    }
    else if (this->b == b.b){
      if(this->weight >= b.weight){
        return false;
      }
      else {
        return true;
      }
    }
  }
};


struct eqtypeind{
  bool operator()(unsigned int s1, unsigned int s2) const {
    return s1 == s2;
  }
};

struct equint{
  bool operator()(unsigned int s1, unsigned int s2) const {
    return s1 == s2;
  }
};

struct eqfloat{
  bool operator()(float s1, float s2) const {
    return s1 == s2;
  }
};

//using google;
//using __gnu_cxx::hash;

/**
* SupervoxelSegmentation class
*
* class that wraps an incremental watershed by first calculating all local
* minima and doing a normal watershed to identify all catchment basins.
*
* then a graph representing these catchment basins and thier overflow borders is
* constructed to be able to do a sublinear watershed on user provided labels.
*/
template<class TYPE_IND, class CT, class CT2, class ST>
class SupervoxelSegmentation {
  private:
    typedef typename vigra::NumpyArray<1, CT, ST >::difference_type oneDShape;
    typedef typename vigra::NumpyArray<3, TYPE_IND, ST >::difference_type threeDShape;
    //typedef typename std::hash_map< TYPE_IND, float > myMapTypeFloat;
    //typedef typename google::sparse_hash_map< unsigned int, float, hash< unsigned int>, equint> myMapTypeIndNew;
    typedef typename std::map< TYPE_IND, PassInfo<TYPE_IND, CT>*> myMapTypeInfo;
    
    vigra::NumpyArray<3, TYPE_IND, ST > _volumeBasins;
    TYPE_IND _minimaCount;
    //std::vector< myMapTypeFloat > _passHoehe;
    //std::vector< myMapTypeInd > _passSize;
    //std::vector< myMapTypeInd > _passTotalHoehe;
    std::vector< AdjacencyListVertex< TYPE_IND, CT > > _graph;
    std::vector< AdjacencyListEdge< TYPE_IND,CT > > _cachedEdges;

    vigra::NumpyArray<1, unsigned char, ST> basinSeedNumber;

    vigra::NumpyArray<1, TYPE_IND, ST > _adjustedIndices;
    
    vigra::NumpyArray<1, vigra::UInt8, ST>  _labelNumbers;
    
    
    std::vector< std::vector<PassInfo<TYPE_IND, CT> > > _neighbourhoods;
    
    CT _minimumHeight;
    CT  _maximumHeight;
    CT _realMinimumHeight;
    CT  _realMaximumHeight;
    int _queueCount;    
    float _lastSigmaGC;
    float _lastSigmaRW;
    char _currentGraph;
    unsigned int _numEdges;
    unsigned char maxLabel;
    bool useDifference;
    vigra::NumpyArray<3, CT, ST> _vol;
    
    vigra::NumpyArray<2, float, ST> _potentials;
    
    float _GCmaximumEdgeWeight;
    TYPE_IND _GCnumEdges;
    
    
    
    /**
    * private helper function that does the initial watershed and labeling of the basins
    */
    void constructBasins ( const vigra::NumpyArray<3, CT, ST>& vol, bool dontUseSuperVoxels){
        _graph.clear();
        //_vol.reshape(vol.shape());
        _vol = vol;

        // define _queueCount queues, one for each gray level.
        std::vector<std::queue<vigra::MultiArrayIndex> > queues;
        queues.resize(_queueCount+1);                
        _volumeBasins.reshape(vol.shape());
        
        if(!dontUseSuperVoxels) {
            printf("Constructing supervoxels :\n");

            //calculate the watershed seeds, and number of minima
            _minimaCount = UniqueLocalMinima3D<CT, TYPE_IND, ST >(vol, _volumeBasins);

            printf("Number of supervoxels %d   -->  compression ratio: %f\n",(int)_minimaCount, (float) _minimaCount / (vol.shape(0)*vol.shape(1)*vol.shape(2)));


                unsigned int quenr;
                //printf("Adding Minimas...\n");
                typename vigra::MultiArrayView<3, CT >::difference_type normalShape = vol.shape();
                //printf("Shape [%d, %d, %d]\n", normalShape[0],normalShape[1],normalShape[2]);

                // add each minimum
                // to the queue corresponding to its gray level
                for(vigra::MultiArrayIndex j = 0; j < _volumeBasins.size(); ++j) {
                typename vigra::NumpyArray<3, CT, ST >::difference_type coordinate = vol.scanOrderIndexToCoordinate(j);
                if(_volumeBasins[j] != 0) {
                    //printf("Adding minima [%d, %d, %d] : %d\n", coordinate[0],coordinate[1],coordinate[2], _volumeBasins[j]);
                    quenr = (float)(vol[j] - _minimumHeight)*((float)_queueCount/_maximumHeight);
                    queues[quenr].push(j);
                    _volumeBasins[j] = _volumeBasins[j] - 1;
                    //_graph[_volumeBasins[j]].color = vol[j];
                }

                }

        }
        else{
            _minimaCount = vol.shape(0)*vol.shape(1)*vol.shape(2);
            TYPE_IND count = 0;
            
            for(TYPE_IND i = 0; i< vol.shape(0); ++i){
                for(TYPE_IND j = 0; j< vol.shape(1); ++j){
                    for(TYPE_IND k = 0; k< vol.shape(2); ++k){
                        _volumeBasins[count] = count;
                        queues[0].push(count);
                        count++;
                    }   
                }
            }
        }
        
        int t1 = clock();

        unsigned int maxCount = vol.shape(0)*vol.shape(1)*vol.shape(2);
        unsigned int onePercent = maxCount / 100;
        unsigned int tenPercent = maxCount / 10;
        unsigned char percents = 0;
        unsigned int currentCount = 0;

        printf("Flooding...\n");

        _neighbourhoods.clear();
        _neighbourhoods.resize(_minimaCount);
        
        // flood
        int grayLevel = 0;
        for(;;) {
          while(!queues[grayLevel].empty()) {
            // label pixel and remove from queue
            vigra::MultiArrayIndex j = queues[grayLevel].front();
            queues[grayLevel].pop();

	    
            currentCount++;
            if(currentCount > tenPercent) {
              percents+=10;
              currentCount = 0;
              printf("finished %d\%\n",percents);
            }
	    
	    
            // add unlabeled neighbors to queues
            // left, upper, and front voxel
            typename vigra::NumpyArray<3, CT, ST >::difference_type coordinate = vol.scanOrderIndexToCoordinate(j);
            typename vigra::NumpyArray<3, CT, ST >::difference_type coordinate_temp = vol.scanOrderIndexToCoordinate(j);
            
            _realMinimumHeight = std::min(vol[coordinate_temp],_realMinimumHeight);
            _realMaximumHeight = std::max(vol[coordinate_temp], _realMaximumHeight);
            
            
            for(unsigned short d = 0; d<3; ++d) {
              if(coordinate[d] != 0) {
                --coordinate[d];
                TYPE_IND l1 = std::max(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                TYPE_IND l2 = std::min(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                CT curPixelLevel;
                if(useDifference) {
                    curPixelLevel = abs((vol[coordinate] - vol[coordinate_temp])/2);
                }
                else{
                    curPixelLevel = (vol[coordinate] + vol[coordinate_temp])/2;
                }
                int curWeight = std::max((int)((curPixelLevel - _minimumHeight)*(_queueCount/_maximumHeight)), grayLevel);
                if(_volumeBasins[coordinate] == 0) {
                  vigra::MultiArrayIndex k = vol.coordinateToScanOrderIndex(coordinate);
                  _volumeBasins[k] = _volumeBasins[j]; // label pixel
                  queues[curWeight].push(k);
                }
                //when neighbour node is already labeled, check for lowest passHoehe
                else if(l1 > l2) {
                  _neighbourhoods[l2].push_back(PassInfo<TYPE_IND,CT>(l1,curPixelLevel));
                }
                ++coordinate[d];
                }
            }
            // right, lower, and back voxel
            for(unsigned short d = 0; d<3; ++d) {
              if(coordinate[d] < _volumeBasins.shape(d)-1) {
                ++coordinate[d];
                TYPE_IND l1 = std::max(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                TYPE_IND l2 = std::min(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                CT curPixelLevel;
                if(useDifference) {
                    curPixelLevel = abs((vol[coordinate] - vol[coordinate_temp])/2);
                }
                else{
                    curPixelLevel = (vol[coordinate] + vol[coordinate_temp])/2;
                }                int curWeight = std::max((int)((curPixelLevel - _minimumHeight)*(_queueCount/_maximumHeight)), grayLevel);
                if(_volumeBasins[coordinate] == 0) {
                  vigra::MultiArrayIndex k = vol.coordinateToScanOrderIndex(coordinate);
                  _volumeBasins[k] = _volumeBasins[j]; // label pixel
                  queues[curWeight].push(k);
                }
                //when neighbour node is already labeled, check for lowest passHoehe
                else if(l1 > l2) {
                  _neighbourhoods[l2].push_back(PassInfo<TYPE_IND,CT>(l1,curPixelLevel));
                }
              --coordinate[d];
              }
            }
          }
          if(grayLevel == _queueCount) {
            break;
          }
          else {
            //queues[grayLevel].clear(); // free memory
            ++grayLevel;
          }
        }
        queues.clear();
        printf("MinimumLocalWeight: %d, MaximumLocalWeight: %d\n",_realMinimumHeight,_realMaximumHeight);
        printf("done.\n");
        
        #pragma omp parallel for
        for(int i = 0; i<_neighbourhoods.size();++i){
          sort(_neighbourhoods[i].begin(),_neighbourhoods[i].end());
        }

      int t2 = clock();

      double time = (t2 - t1) * 1.0 / CLOCKS_PER_SEC;

      printf("Preprocessing() took: %f\n", time);
        
    }


      public:
          
          
  void setSeeds(const vigra::MultiArrayView<1, vigra::UInt8, ST>& labelNumbers, const vigra::MultiArrayView<1, TYPE_IND, ST>& labelIndices) {


      /*
      * begin really stupid c/fortran order indices conversion
      */
      _labelNumbers.reshape(labelNumbers.shape());
      for(int i=0;i<_labelNumbers.size();++i) {
          _labelNumbers[i] = labelNumbers[i];
      }
      
      _adjustedIndices.reshape(labelIndices.shape());

      typename vigra::MultiArrayView<3, TYPE_IND, ST >::difference_type switchedShape = _volumeBasins.shape();
      //printf("Original Shape [%d, %d, %d]\n", switchedShape[0],switchedShape[1],switchedShape[2]);
      switchedShape[0] = switchedShape[2];
      switchedShape[2] = _volumeBasins.shape()[0];

      for(int i = 0; i < _adjustedIndices.size(); ++i) {
        vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate;
        vigra::detail::ScanOrderToCoordinate<3>::exec(labelIndices(i), switchedShape, coordinate);

        unsigned int tempI = coordinate[0];
        coordinate[0] = coordinate[2];
        coordinate[2] = tempI;
        //printf("CoordinateA [%d, %d, %d] : %d, basin %d\n", coordinate[0],coordinate[1],coordinate[2],labelNumbers[i], _volumeBasins[coordinate]);
        _adjustedIndices(i) = _volumeBasins.coordinateToScanOrderIndex(coordinate);
      }
      /*
      * end really stupid c/fortran order indices conversion
      */

      std::vector<bool> labelCollision;
      labelCollision.resize(_minimaCount, false);
      
      bool labelCollisions = true;
      
      while(labelCollisions) {
        labelCollisions = false;
        
        //reset basinSeedNumbers
        basinSeedNumber.reshape(oneDShape(_minimaCount)); //make room for 2 labels : border and bridges
        for(TYPE_IND i=0; i < _minimaCount; ++i) {
            basinSeedNumber(i) = 0;
        }
        
        //reset maxLabel
        maxLabel = 0;
        
        for(TYPE_IND i = 0; i < _labelNumbers.shape(0); ++i) {
            TYPE_IND index = _adjustedIndices[i];
            unsigned char label = _labelNumbers[i];
            vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate = _volumeBasins.scanOrderIndexToCoordinate(index);

            TYPE_IND basin = _volumeBasins[coordinate];
            maxLabel = std::max(label,maxLabel);

            //check for seed collision in basins
            if ( (basinSeedNumber[basin] == 0 || basinSeedNumber[basin] == label)) {
                basinSeedNumber[basin] = label;
            }
            else {
                labelCollisions = true;
                handleLabelCollision(basin, coordinate);
                printf("recalculating seeds\n");
                break;
            }
        }
      }
  }
          
 void handleLabelCollision(TYPE_IND basin, typename vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate) {
    typedef typename vigra::NumpyArray<3, CT, ST >::difference_type VCOORD;

    printf("Seed Collision in Basin %d, splitting up basin\n", basin);
    
    VCOORD coordinate_temp = coordinate;
    std::queue<VCOORD> basinPixels;
    TYPE_IND basinPixelCount = 0;
    basinPixels.push(coordinate);
    TYPE_IND maxBasin = std::numeric_limits<TYPE_IND>::max();
    
    _volumeBasins[coordinate] = maxBasin;
    
    printf("a\n");
    
    while(!basinPixels.empty()){
        coordinate_temp = basinPixels.front();
        
        basinPixels.pop();
        
        basinPixelCount++;
        for(unsigned short d = 0; d<3; ++d) {
            if(coordinate_temp[d] != 0) {
                --coordinate_temp[d];
                if(_volumeBasins[coordinate_temp] == basin) {
                   _volumeBasins[coordinate_temp] = maxBasin;
                   basinPixels.push(coordinate_temp);
                }
                ++coordinate_temp[d];
            }
        }
        for(unsigned short d = 0; d<3; ++d) {
            if(coordinate_temp[d] < _volumeBasins.shape(d)-1) {
                ++coordinate_temp[d];
                if(_volumeBasins[coordinate_temp] == basin) {
                   _volumeBasins[coordinate_temp] = maxBasin; 
                   basinPixels.push(coordinate_temp);
                }                
                --coordinate_temp[d];
            }
        }
    }
    printf("b\n");
    
    TYPE_IND oldMinimaCount = _minimaCount;
    
    //adjust minimaCount
    _minimaCount += basinPixelCount;
    printf("c\n");
            
    //remove obsolete entries from the neighborhood lists
    std::vector< std::vector<PassInfo<TYPE_IND, CT> > > tempNeighbourhoods;
    tempNeighbourhoods.resize(_minimaCount); //NEW minimum count
    //printf("d\n");
    
    #pragma omp parallel for
    for(int i = 0; i<oldMinimaCount;++i){
        tempNeighbourhoods[i] = _neighbourhoods[i];
    }    
    printf("e\n");
    
    //delete and resize old neighborhoods
    _neighbourhoods.clear();
    _neighbourhoods.resize(_minimaCount); //new minima count

    printf("f\n");
    
    //renumber the basin pixels and add new passinfos
    TYPE_IND currentMinimum = oldMinimaCount;    
    _volumeBasins[coordinate] = currentMinimum;
    currentMinimum++;

    basinPixels.push(coordinate);
    printf("g\n");
    
    while(!basinPixels.empty()){
        
        coordinate_temp = basinPixels.front();
        coordinate = coordinate_temp;
        
        basinPixels.pop();
                
        for(unsigned short d = 0; d<3; ++d) {
            if(coordinate_temp[d] != 0) {
                --coordinate_temp[d];
                if(_volumeBasins[coordinate_temp] == maxBasin) {
                    //also relabel so that it does not get added again
                   _volumeBasins[coordinate_temp] = currentMinimum;
                   currentMinimum++;
                   basinPixels.push(coordinate_temp);
                }
                TYPE_IND l1 = std::max(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                TYPE_IND l2 = std::min(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                
                CT curPixelLevel;
                
                //printf("naja\n");
                if(useDifference) {
                    curPixelLevel = abs((_vol[coordinate] - _vol[coordinate_temp])/2);
                }
                else{
                    curPixelLevel = (_vol[coordinate] + _vol[coordinate_temp])/2;
                }                
                //printf("naja2\n");
                
                if(l1 > l2) {
                  _neighbourhoods[l2].push_back(PassInfo<TYPE_IND,CT>(l1,curPixelLevel));
                }
                
                ++coordinate_temp[d];
            }
        }
        for(unsigned short d = 0; d<3; ++d) {
            if(coordinate_temp[d] < _volumeBasins.shape(d)-1) {
                ++coordinate_temp[d];
                if(_volumeBasins[coordinate_temp] == maxBasin) {
                    //also relabel so that it does not get added again
                   _volumeBasins[coordinate_temp] = currentMinimum; 
                   currentMinimum++;
                   basinPixels.push(coordinate_temp);
                }                

                TYPE_IND l1 = std::max(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                TYPE_IND l2 = std::min(_volumeBasins[coordinate],_volumeBasins[coordinate_temp]) ;
                
                CT curPixelLevel;
                //printf("naja\n");
                
                if(useDifference) {
                    curPixelLevel = abs((_vol[coordinate] - _vol[coordinate_temp])/2);
                }
                else{
                    curPixelLevel = (_vol[coordinate] + _vol[coordinate_temp])/2;
                }                
                //printf("naja2\n");
                
                if(l1 > l2) {
                  _neighbourhoods[l2].push_back(PassInfo<TYPE_IND,CT>(l1,curPixelLevel));
                }

                --coordinate_temp[d];
            }
        }
    }    
    
    
    printf("h\n");
    
    //copy over old + new passinfos, while removing obsolete connections
    #pragma omp parallel for
    for(int i = 0; i<_neighbourhoods.size();++i){ //OLD minimum count
        if(i!=basin) {
            PassInfo<TYPE_IND, CT> passinfo;
            for(int j=0; j<tempNeighbourhoods[i].size();++j){
                passinfo = tempNeighbourhoods[i][j];
                if(passinfo.b != basin) {
                    _neighbourhoods[i].push_back(passinfo);
                }
            }
        }
    }
    
    printf("i\n");
    
    //sort stuff again
    #pragma omp parallel for
    for(int i = 0; i<_neighbourhoods.size();++i){
        sort(_neighbourhoods[i].begin(),_neighbourhoods[i].end());
    }    
    
    //notify algorithms of changed graph
    _currentGraph = 'Z';
 }

  /**
  * public interface method that does the watershed on the sparse graph.
  *
  * Input: two 1D array consisting of the label or seed Numbers, and their corresponding 3d scanOrderIndices
  *
  * Output: nothing
  *
  * Returns: 	array containg the calculated labelNumbers of the various catchment basins
  * 		should be used as an index table for the basin
  *
  */
  NumpyAnyArray doWS(float bias, float biasThres, unsigned int biasedLabel) {

        if(_currentGraph != 'W') {
            printf("Constructing graph for Watershed ");
            printf("(reason: incompatible graph)");
            printf("...\n");

            //allocate adjacency graph
            _graph.clear();
            _graph.resize(_neighbourhoods.size());

            _numEdges = 0;
            TYPE_IND lastB=0;
            TYPE_IND lastI=0;
            CT weight;
            float sum = 0;
            
            unsigned int size = 0;
            unsigned int totalSize = 0;
            CT minimumW ;

            //construct the basin graph
            for(int i = 0; i<_neighbourhoods.size();++i){
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator it;
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator end = _neighbourhoods[i].end();

                totalSize = 0;
                
                if(_neighbourhoods[i].size() > 0) {
                    lastB = _neighbourhoods[i].begin()->b;
                    minimumW = _neighbourhoods[i].begin()->weight;
                    sum = 0;
                    size = 0;                    
                }
                
                for(it = _neighbourhoods[i].begin(); it  != end; ++it) {
                    if(lastB != it->b){
                        //printf("Edge %d ->, %d: %f\n", i, it->first, weight);
                        
                        //(CT)((it->weight - _minimumHeight) * (float) _queueCount / _maximumHeight);
                        AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                        AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                        _graph[lastB].edges.push_back(e1);
                        _graph[i].edges.push_back(e2);
                        _numEdges +=2;
                        lastB = it->b;
                        lastI = i;
                        minimumW = it->weight;
                        
                        sum = 0;
                        size = 0;
                    }
                    sum += it->weight;
                    size++;
                    totalSize++;
                }

                if(_neighbourhoods[i].size() > 0) {
                    AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                    AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                    _graph[lastB].edges.push_back(e1);
                    _graph[i].edges.push_back(e2);        
                }
                _graph[i].totalSize = totalSize;
                lastI = i;
                
            }
        printf(" done !\n");
        _currentGraph = 'W';
      }
      
      
      
      
      printf("Executing watershed on %d Vertices and %d Edges...\n", (int) _minimaCount, (int) _numEdges);
      
      
      unsigned int t1 = clock();

      //printf("doing supervoxel watershed with bias %f for label %d\n",_bias, _biasedLabel);
      
      std::vector< AdjacencyListVertex< TYPE_IND, CT > > graphCopy = _graph;

      //reset basinSeedNumbers
      basinSeedNumber.reshape(oneDShape(_minimaCount)); //make room for 2 labels : border and bridges
      for(TYPE_IND i=0; i < _minimaCount; ++i) {
        basinSeedNumber(i) = 0;
      }
      
      // define a priority queue
      std::priority_queue< AdjacencyListEdge<TYPE_IND, CT>*, std::vector<AdjacencyListEdge<TYPE_IND, CT >* >, edgeSortClass<TYPE_IND, CT> > queue;

      unsigned char maxLabel = 0;


      // define 2048 queues, one for each value.
      std::vector<std::queue<AdjacencyListEdge<TYPE_IND, CT>*> > queues;
      queues.resize(_queueCount+1);

      
      for(TYPE_IND i = 0; i < _labelNumbers.shape(0); ++i) {
        TYPE_IND index = _adjustedIndices[i];
        unsigned char label = _labelNumbers[i];
        vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate = _volumeBasins.scanOrderIndexToCoordinate(index);

        TYPE_IND basin = _volumeBasins[coordinate];
        maxLabel = std::max(label,maxLabel);

        basinSeedNumber[basin] = label;
        // add each unlabeled basin bordering a labeled basin to the priority queue
        AdjacencyListVertex< TYPE_IND, CT >* v = &graphCopy[basin];
        for(TYPE_IND j=0; j < v->edges.size();++j) {
        AdjacencyListEdge< TYPE_IND, CT > *e = &v->edges[j];

        if(basinSeedNumber[e->other] == 0) {
            //printf("weight %d\n", e->weight);
            int weight = e->min;
            queues[weight].push(e);
        }
        }
      }

      int waterLevel = 0;


      for(;;){
        while(!queues[waterLevel].empty()) {
          // label pixel and remove from queue
          AdjacencyListEdge<TYPE_IND, CT>* e1 = queues[waterLevel].front();
          queues[waterLevel].pop();
          vigra::MultiArrayIndex i = e1->other;
          float factor = 1.0;
          TYPE_IND minVertex;
          AdjacencyListEdge< TYPE_IND, CT >* e;

          
          
          if(basinSeedNumber[i] == 0) { //still unlabeled ?
            basinSeedNumber[i] = basinSeedNumber[e1->here];

            if(basinSeedNumber[i] == 0) {
                printf("hae?: %d\n", i);
            }
            
            if(basinSeedNumber[i] == biasedLabel) {
              factor = bias;
            }

            //graphCopy[i].price = std::max(graphCopy[e1->here].price,e1->weight * factor);

            AdjacencyListVertex< TYPE_IND, CT >* v = &(graphCopy[i]);

            for(TYPE_IND j=0; j < v->edges.size();++j) {
                e = &(v->edges[j]);
                if(basinSeedNumber[e->other] == 0) { //unlabeled
                  int weight;
                  if(e->min > biasThres) {
                    weight = std::max(waterLevel, (int)(e->min * factor));
                    //printf("weight: %d\n", weight);
                  }
                  else {
                    weight = std::max(waterLevel, (int)(e->min));
                  }
                queues[weight].push(e);
                }
              }
          }
        }
        if(waterLevel==_queueCount){
          break;
        }
        else{
          waterLevel++;
        }
      }

      int t2 = clock();

      double time = (t2 - t1) * 1.0 / CLOCKS_PER_SEC;

      printf("Algorithm() took: %f\n", time);

      return basinSeedNumber;
    }


    NumpyAnyArray doGC(float sigma){
        float sigmasq = pow(sigma,2);        
        
        if((_currentGraph != 'G')||(sigma != _lastSigmaGC)) {
            printf("Constructing graph for GraphCut ");
            if(_currentGraph != 'G') {
                printf("(reason: incompatible graph)");
            }
            else {
                printf("(reason: different sigma)");
            }
            printf("...\n");
            
            _lastSigmaGC = sigma;

            //allocate adjacency graph
            _graph.clear();
            _graph.resize(_neighbourhoods.size());

            TYPE_IND lastB=0;
            TYPE_IND lastI=0;
            CT weight;
            float sum = 0;
            
            unsigned int size = 0;
            unsigned int totalSize = 0;
            CT minimumW ;

            float _maxSum = 0;
            float _minSum = std::numeric_limits<float>::max();            
            _GCnumEdges = 0;
            
            //construct the basin graph
            for(int i = 0; i<_neighbourhoods.size();++i){
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator it;
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator end = _neighbourhoods[i].end();

                totalSize = 0;
                
                if(_neighbourhoods[i].size() > 0) {
                    lastB = _neighbourhoods[i].begin()->b;
                    minimumW = _neighbourhoods[i].begin()->weight;
                    sum = 0;
                    size = 0;
                    lastI = i;
                }
                
                for(it = _neighbourhoods[i].begin(); it  != end; ++it) {
                    if(lastB != it->b){
                        //printf("Edge %d ->, %d: %f\n", i, it->first, weight);
                        
                        //(CT)((it->weight - _minimumHeight) * (float) _queueCount / _maximumHeight);
                        _maxSum = std::max(_maxSum, sum);
                        _minSum = std::min(_minSum, sum);
                        AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                        //AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                        _GCnumEdges ++;
                        _graph[lastB].edges.push_back(e1);
                        //_graph[i].edges.push_back(e2);
                        
                        lastB = it->b;
                        minimumW = it->weight;
                        
                        sum = 0;
                        size = 0;
                    }
                    sum += exp(-pow(((float)(it->weight-_realMinimumHeight)/(_realMaximumHeight-_realMinimumHeight)),2) / 2 / sigmasq);
                    size++;
                    totalSize++;
                }

                if(_neighbourhoods[i].size() > 0) {
                    _maxSum = std::max(_maxSum, sum);
                    _minSum = std::min(_minSum, sum);
                    AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                   // AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                    _GCnumEdges ++;
                    _graph[lastB].edges.push_back(e1);
                    //_graph[i].edges.push_back(e2);        
                }
                _graph[i].totalSize = totalSize;
                
            }
        printf("MinimumWeight: %f, MaximumWeight: %f\n",_minSum, _maxSum);
        _GCmaximumEdgeWeight = _maxSum;
        printf(" done\n");
        _currentGraph = 'G';
      }        
        
        
        unsigned int t1 = clock();
        
        
        //reset basinSeedNumbers
        basinSeedNumber.reshape(oneDShape(_minimaCount)); //make room for 2 labels : border and bridges
        for(TYPE_IND i=0; i < _minimaCount; ++i) {
            basinSeedNumber(i) = 0;
        }        
        
        typedef Graph< float, float, float> GraphType;

        unsigned int nodes = _minimaCount;
        unsigned int edges = nodes * 10;

        GraphType g(/*estimated # of nodes*/ nodes, /*estimated # of edges*/ _GCnumEdges, &real_error_function);

        AdjacencyListEdge< TYPE_IND, CT >* e;
        AdjacencyListVertex< TYPE_IND, CT >* v;
        
        //construct graph for kolmogorov
        for(TYPE_IND i=0;i < _minimaCount; ++i) {
            g.add_node();
        }
        
        //just as a reminder
        TYPE_IND source = 0;
        TYPE_IND sink = 1;
        
        printf("adding unary potentials...\n");
        //add unary potentials for seeds
        for(TYPE_IND i = 0; i < _labelNumbers.shape(0); ++i) {
            TYPE_IND index = _adjustedIndices[i];
            unsigned char label = _labelNumbers[i];
            vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate = _volumeBasins.scanOrderIndexToCoordinate(index);

            TYPE_IND basin = _volumeBasins[coordinate];
            //basinSeedNumber[basin] = label;
            
            if(label == 1) { //background <-> source
                g.add_tweights( basin,  std::numeric_limits<float>::max(), 0);
            }        
            else{ //foreground
                g.add_tweights( basin, 0, std::numeric_limits<float>::max());
            }
        }

        printf("adding binary potentials...\n");

        unsigned int numEdges=0;
        //add binary potentials to graph
        for(TYPE_IND i=0;i < _minimaCount; ++i) {
            v = &(_graph[i]);
            for(TYPE_IND j=0; j < v->edges.size();++j) {
                e = &(v->edges[j]);
                //printf("e->sum: %f, ", e->sum);
                g.add_edge( e->here, e->other,    /* capacities */  e->sum, e->sum);
                numEdges += 2;
            }
        }
    
        printf("computing minimum cut with %d Vertices and %d Edges: ...\n", (int) _minimaCount,(int) _GCnumEdges);
        CT2 flow = g.maxflow();
        printf("done, cut cost: %f\n", flow);

        for(TYPE_IND i=0;i < _minimaCount; ++i) {
            if(g.what_segment(i) == GraphType::SOURCE){  //source <-> background
                basinSeedNumber[i] = 1;
            }
            else { //sink
                basinSeedNumber[i] = 2;
            }
        }

        return basinSeedNumber;

}






  /**
  * public interface method that does the Random Walk on the sparse graph.
  *
  * Input: two 1D array consisting of the label or seed Numbers, and their corresponding 3d scanOrderIndices
  *
  * Output: nothing
  *
  * Returns:    array containg the calculated labelNumbers of the various catchment basins
  *         should be used as an index table for the basin
  *
  */
  NumpyAnyArray doRW(float sigma, std::string options) {

        double sigmasq = sigma* sigma;
      
        if((_currentGraph != 'R')||(sigma != _lastSigmaGC)) {
            printf("Constructing graph for Random Walk ");
            if(_currentGraph != 'R') {
                printf("(reason: incompatible graph)");
            }
            else {
                printf("(reason: different sigma)");
            }
            printf("...\n");
            
            _lastSigmaRW = sigma;

            //allocate adjacency graph
            _graph.clear();
            _graph.resize(_neighbourhoods.size());

            TYPE_IND lastB=0;
            TYPE_IND lastI=0;
            CT weight;
            float sum = 0;
            
            unsigned int size = 0;
            unsigned int totalSize = 0;
            CT minimumW ;

            float _maxSum = 0;
            float _minSum = std::numeric_limits<float>::max();            
            
            //construct the basin graph
            for(int i = 0; i<_neighbourhoods.size();++i){
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator it;
                typename std::vector<PassInfo<TYPE_IND, CT> >::iterator end = _neighbourhoods[i].end();

                totalSize = 0;
                
                if(_neighbourhoods[i].size() > 0) {
                    lastB = _neighbourhoods[i].begin()->b;
                    minimumW = _neighbourhoods[i].begin()->weight;
                    sum = 0;
                    size = 0;
                    lastI = i;                    
                }
                
                for(it = _neighbourhoods[i].begin(); it  != end; ++it) {
                    if(lastB != it->b){
                        //printf("Edge %d ->, %d: %f\n", i, it->first, weight);
                        
                        //(CT)((it->weight - _minimumHeight) * (float) _queueCount / _maximumHeight);
                        _maxSum = std::max(_maxSum, sum);
                        _minSum = std::min(_minSum, sum);
                        AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                        AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                        _graph[lastB].edges.push_back(e1);
                        _graph[i].edges.push_back(e2);
                        
                        lastB = it->b;
                        minimumW = it->weight;
                        
                        sum = 0;
                        size = 0;
                    }
                    sum += exp(-pow(((float)(it->weight-_realMinimumHeight)/(_realMaximumHeight-_realMinimumHeight)),2) / 2 / sigmasq);
                    size++;
                    totalSize++;
                }

                if(_neighbourhoods[i].size() > 0) {
                    _maxSum = std::max(_maxSum, sum);
                    _minSum = std::min(_minSum, sum);
                    AdjacencyListEdge< TYPE_IND,CT > e1(minimumW, sum, size, i, lastB);
                    AdjacencyListEdge< TYPE_IND,CT > e2(minimumW, sum, size, lastB, i);
                    _graph[lastB].edges.push_back(e1);
                    _graph[i].edges.push_back(e2);        
                }
                _graph[i].totalSize = totalSize;
                
            }
        printf("MinimumWeight: %f, MaximumWeight: %f\n",_minSum, _maxSum);
        printf(" done\n");
        _currentGraph = 'R';
    }        
      

    //reset basinSeedNumbers
    basinSeedNumber.reshape(oneDShape(_minimaCount)); //make room for 2 labels : border and bridges
    for(TYPE_IND i=0; i < _minimaCount; ++i) {
        basinSeedNumber(i) = 0;
    }
      
    unsigned char num_labels = 0;
    
    //set basin seed numbers
    for(TYPE_IND i = 0; i < _labelNumbers.shape(0); ++i) {
        TYPE_IND index = _adjustedIndices[i];
        unsigned char label = _labelNumbers[i];
        vigra::MultiArrayView<3, vigra::UInt32>::difference_type coordinate = _volumeBasins.scanOrderIndexToCoordinate(index);
        TYPE_IND basin = _volumeBasins[coordinate];
        basinSeedNumber[basin] = label;
        num_labels = std::max(num_labels,label);
    }
      
    char *argv[] = {""};

    int argc = 0;
    lis_initialize(&argc,(char ***) &argv);

    LIS_MATRIX A;
    LIS_SOLVER solver;
    lis_solver_create(&solver);

    char *cs;
    cs = (char*) malloc(options.size());
    std::strcpy(cs,options.c_str());      
    
    lis_solver_set_option(cs, solver);

    lis_matrix_create(0,&A);
    
    std::vector<unsigned int> coefficientIndex;
    coefficientIndex.resize(_minimaCount);
    
    //count unlabeled nodes and set coefficient indicies
    unsigned int num_unlabeled_nodes = 0;
    for(int i=0;i<_minimaCount;++i){
        if(basinSeedNumber[i]==0) {
            coefficientIndex[i] = num_unlabeled_nodes;
            num_unlabeled_nodes++;
        }
        else {
            coefficientIndex[i] = 0;
        }
    }

    lis_matrix_set_size(A,0,num_unlabeled_nodes);    

    
    std::vector<std::vector<size_t> > B;
    B.resize(num_labels, std::vector<size_t>());
    std::vector<std::vector<double> > B_weights;
    B_weights.resize(num_labels, std::vector<double>());

    std::vector<std::vector<double> > resultProbabilities;
    resultProbabilities.resize(num_labels, std::vector<double>());
    
    for(int i = 0; i < num_labels; ++i) {
        resultProbabilities.resize(_minimaCount);
    }

    printf("adding binary potentials...\n");
    AdjacencyListEdge< TYPE_IND, CT >* e;
    AdjacencyListVertex< TYPE_IND, CT >* v;
        
    unsigned int numEdges=0;

    //  count required nonzero matrix entries
    
    //space for diagonals
    unsigned int matrixEntries = num_unlabeled_nodes;
    //off diagonals
    for(TYPE_IND i=0;i < _minimaCount; ++i) {
        v = &(_graph[i]);
        if(basinSeedNumber[i] == 0) {
            for(TYPE_IND j=0; j < v->edges.size();++j) {
                e = &(v->edges[j]);            
                if(basinSeedNumber[e->other] == 0) {
                    matrixEntries++;
                }
            }
        }
    }        
    
    int *mrows = (int*) malloc(matrixEntries * sizeof(int));
    int *mcols = (int*) malloc(matrixEntries * sizeof(int));
    LIS_SCALAR *mvalues = (LIS_SCALAR*) malloc(matrixEntries * sizeof(LIS_SCALAR));
    
    //initialize diagonal matrix entries
    for(int i = 0; i < num_unlabeled_nodes; ++i) {
        mvalues[i] = 0.0;
        mrows[i] = i;
        mcols[i] = i;
        
    }
    
    unsigned int matrixEntryCounter = num_unlabeled_nodes;
    
    //add off diagonal (binary potentials) to maxtrix
    for(TYPE_IND i=0;i < _minimaCount; ++i) {
        v = &(_graph[i]);
    
        unsigned int left = coefficientIndex[i];
        
        if(basinSeedNumber[i] == 0) {
            for(TYPE_IND j=0; j < v->edges.size();++j) {
                e = &(v->edges[j]);
                
                unsigned int right = coefficientIndex[e->other];
                
                //left node unlabeled anyways
                //other node also unlabeled
                if(basinSeedNumber[e->other] == 0) {
                    mrows[matrixEntryCounter] = left;
                    mcols[matrixEntryCounter] = right;
                    mvalues[matrixEntryCounter] = -e->sum;
                    mvalues[left] += e->sum; //add to diagonal
                    matrixEntryCounter++;
                }
                //left unlabeled, right labeled
                else {
                    //remember edge weight, and add it later as bounday when we solve for that label
                    B[basinSeedNumber[e->other]-1].push_back(left);
                    B_weights[basinSeedNumber[e->other]-1].push_back(e->sum);
                    //diagonal needs to be adjusted anyways,
                    //if b is not increased it means boundary value of 0 -> thats exactly
                    //what we want 
                    mvalues[left] += e->sum; //add to diagonal
                }
            }
        }
    }
            
    printf("Computing Random walk with %d unlabled vertices and %d nonzero matrix entries: ...\n", num_unlabeled_nodes, matrixEntries);
    
    lis_matrix_set_coo(matrixEntries,mrows, mcols, mvalues, A);
    lis_matrix_assemble(A);
/*
 *
 * Old lis matrix construciton -> slow
 */

    
//     //add binary potentials to graph
//     for(TYPE_IND i=0;i < _minimaCount; ++i) {
//         v = &(_graph[i]);
//         for(TYPE_IND j=0; j < v->edges.size();++j) {
//             e = &(v->edges[j]);
//             
//             //left node unlabeled
//             unsigned int left = coefficientIndex[e->here];
//             unsigned int right = coefficientIndex[e->other];
//             
//             if((left > num_unlabeled_nodes)||(right>num_unlabeled_nodes)) {
//                 printf("ERROR: %d, %d, %d\n",left, right, num_unlabeled_nodes);
//             }
//             
//             if(basinSeedNumber[e->here] == 0) {
//                 //other node also unlabeled
//                 if(basinSeedNumber[e->other] == 0) {
//                     lis_matrix_set_value(LIS_INS_VALUE,left, right, -e->sum,A);
//                     //lis_matrix_set_value(LIS_INS_VALUE,right, left, -e->sum ,A);
//                     lis_matrix_set_value(LIS_ADD_VALUE,left, left, e->sum,A);
//                     //lis_matrix_set_value(LIS_ADD_VALUE,right, right, e->sum,A);
//                 }
//                 //left unlabeled, right labeled
//                 else {
//                     B[basinSeedNumber[e->other]-1].push_back(left);
//                     B_weights[basinSeedNumber[e->other]-1].push_back(e->sum);
//                     lis_matrix_set_value(LIS_ADD_VALUE,left, left, e->sum,A);                    
//                 }
//             }
//             //left node labeled
//             //else {
//             //    //right node unlabeled
//             //    if(basinSeedNumber[e->other] == 0) {
//             //        B[basinSeedNumber[e->here]-1].push_back(right);
//             //        B_weights[basinSeedNumber[e->here]-1].push_back(e->sum);
//             //        lis_matrix_set_value(LIS_ADD_VALUE,right,right, e->sum,A);                    
//             //    }
//             //}
//         }
//     }    
//     lis_matrix_set_type(A,LIS_MATRIX_COO);
//     lis_matrix_assemble(A);
      

    _potentials.reshape(typename  vigra::NumpyArray<2, float, ST>::difference_type(basinSeedNumber.shape(0) , (int)num_labels));

    for (uint8_t label = 1; label <= num_labels ; ++label)
    {
        printf("solving for label %d ...\n",label);


        LIS_VECTOR x;
        LIS_VECTOR b;
        
        lis_vector_duplicate(A,&b);
        lis_vector_duplicate(A,&x);

        lis_vector_set_all(0,b);
        
        for (size_t i = 0; i < B[label-1].size(); ++i)
        {
            lis_vector_set_value(LIS_ADD_VALUE,B[label-1][i],B_weights[label-1][i],b);
        }

        lis_vector_set_all(0.5,x);
        lis_solve(A,b,x,solver);
        //results should now hold the probabilities of the unlabeled nodes for the current label

        resultProbabilities[label-1].resize(_minimaCount);
        
        unsigned int offset_unlabeled_node = 0;
        for(unsigned int i=0;i<_minimaCount;++i){
            if (basinSeedNumber[i] == 0) {
                LIS_SCALAR f;
                lis_vector_get_value(x,offset_unlabeled_node, &f);
                resultProbabilities[label - 1][i] = (float) f;
                offset_unlabeled_node++;
            }
            else if (basinSeedNumber[i]==label){
                resultProbabilities[label-1][i] = 1.0;
            }
            else resultProbabilities[label-1][i] = 0;
        }

        lis_vector_destroy(b);
        lis_vector_destroy(x);
    }

    lis_matrix_destroy(A);
    lis_solver_destroy(solver);
    lis_finalize();

    for(unsigned int i=0;i<_minimaCount;++i){
        char maxL = 0;
        float maxProb = 0;
        for(unsigned char l=0;l<num_labels;++l){
            _potentials(i,l) = resultProbabilities[l][i];
            if(resultProbabilities[l][i] > maxProb){
                maxProb = resultProbabilities[l][i];
                maxL = l;
            }
        }
        basinSeedNumber(i) = maxL+1;
    }
    
    return basinSeedNumber;
    
}









    /**
    * Public interface function - returns the calculated basinNumbers of the Volume
    *
    */
    NumpyAnyArray getVolumeBasins(vigra::NumpyArray<3, TYPE_IND, ST> res) {

      //res.reshape(_volumeBasins.shape());

      vigra::NumpyArray<3, TYPE_IND, ST> result = _volumeBasins;

      return result;
    }

    /**
    * Public interface function - returns the potentials of the basins regarding the labels
    *
    */
    NumpyAnyArray getBasinPotentials() {
      vigra::NumpyArray<2, float, ST> res = _potentials;
      
      return res;
    }

    /**
    * Public interface function - returns the calculated basinNumbers of the Volume
    *
    */
    NumpyAnyArray getBorderVolume() {

      vigra::NumpyArray<3, unsigned char, ST> res;
      res.reshape(_volumeBasins.shape());

      //mark borders
      for(int j=0; j < _volumeBasins.size();++j) {
        typename vigra::NumpyArray<3, TYPE_IND, ST >::difference_type coordinate = _volumeBasins.scanOrderIndexToCoordinate(j);
        for(unsigned short d = 0; d<3; ++d) {
          if(coordinate[d] != 0) {
            --coordinate[d];
            if(_volumeBasins[coordinate] != _volumeBasins[j]) {
              res[j] = 1;
            }
            else {
                res[j] = 0;
            }
          ++coordinate[d];
          }
        } 
      }
      return res;
    }


    /**
    * constructor, calculates the local minimy and catchment basins of the provided volume
    *
    * Input: 	a 3d Volume of unsigned chars
    *
    * Output:	nothing
    */
    SupervoxelSegmentation(const vigra::NumpyArray<3, CT, ST>& vol, bool useDiff, float minimum, float maximum, int queuecount, bool dontUseSuperVoxels)
    {
      //construct the basin graph, and label the volume according to the watershed algorithm from the minima
      _minimumHeight = minimum;
      _maximumHeight = maximum;
      _realMinimumHeight = std::numeric_limits<CT>::max();
      _realMaximumHeight = 0;
      _currentGraph = 'Z';
      _lastSigmaGC = 0;
      _queueCount = queuecount;
      useDifference = useDiff;
      constructBasins(vol, dontUseSuperVoxels);
    }


    /**
    * destructor,
    */
    ~SupervoxelSegmentation() {
      //clear stuff
/*	    for(TYPE_IND i = 0; i < _cachedEdges.size();++i) {
        delete _cachedEdges[i];
      }*/
      _cachedEdges.clear();

/*	    for(TYPE_IND i = 0; i < graphCopy.size();++i) {
        AdjacencyListVertex< TYPE_IND >* v = &_graph[i];

        for(TYPE_IND j=0; j < v->edges.size();++j) {
    delete v->edges[j];
        }
      }*/
      _graph.clear();

    }
};

} //end namespace

}//namespce vigra

#endif
